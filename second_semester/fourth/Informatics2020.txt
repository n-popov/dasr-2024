Полигон
Задан класс точки на плоскости:

class Point2D
{
protected:
    double _x;
    double _y;

public:
    // Конструктор точки с заданными координатами
    Point2D(double x, double y): _x(x), _y(y) {
    }

    // Получить координату X точки    
    double x() const {
        return _x;
    }

    // Получить координату Y точки
    double y() const {
        return _y;
    }
};
Напишите класс, описывающий выпуклый многоугольник, со следующим прототипом:

#include <vector>

class Polygone
{
public:
    // Конструктор, создаёт полигон из набора точек.
    // Точки передаются в порядке обхода полигона по контуру.
    Polygone(const std::vector<Point2D>& points);

    // Деструктор, если нужен

    // Возвращает площадь полигона
    double area() const;

    // Возвращает количество вершин полигона
    unsigned int size() const;

    // Возвращает N-ую вершину полигона
    // (вершины нумеруются в том же порядке, в котором были переданы)
    Point2D vertex(unsigned int N) const;
};
Указание 1: в данной задаче можно исходить из того, что конструктору будет передан корректный набор точек в порядке обхода полигона по контуру, причём полигон будет выпуклый.

Указание 2: площадь полигона можно посчитать, разделив его на треугольники. Площадь каждого треугольника можно посчитать через векторное произведение, по формуле Герона или любым другим удобным вам методом.

Для базового тестирования можете использовать следующий пример:

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    std::vector<Point2D> points = {{-1.0, -1.0}, {-1.0, 1.0}, {1.0, 1.0}, {1.0, -1.0}};
    Polygone p(points);
    cout << "Points:" << endl;
    for(unsigned int i = 0; i < p.size(); i++) {
        cout << p.vertex(i).x() << " " << p.vertex(i).y() << endl;
    }
    cout << "Area: " << p.area() << endl;
    return 0;
}
Данный пример должен вывести:

Points:
-1.00 -1.00
-1.00 1.00
1.00 1.00
1.00 -1.00
Area: 4.00
(Количество знаков после запятой, которое вы увидите на экране при локальной проверке, неважно. При тестировании решения это будет обработано проверяющим кодом.)

Внимание:

Отправлять в контест нужно только класс Polygone c реализацией его методов. Также нужно отправить необходимые include-ы и using-и к нему.
Отправлять функцию main и класс Point2D не нужно.


Сдать решение задачи atm
Полный балл:	40
Штраф за посылку:	1
Ограничение времени:	2 с
Ограничение реального времени:	2 с
Ограничение памяти:	64M
Банкомат
Напишите класс, описывающий устройство приёма и выдачи купюр банкомата:

#include <vector>

class ATM
{
public:
    // Конструктор, создаёт пустой банкомат
    ATM();

    // Деструктор, если нужен

    // Вносит в устройство набор купюр
    // - в векторе notes перечислены достоинства вносимых купюр (разумеется, возможны повторы)
    // - в поле currency указан код валюты
    void deposit(const std::vector<unsigned int>& notes, unsigned short int currency);

    // Снять сумму amount в валюте currency, выдав её максимально крупными купюрами
    // - если операция прошла успешно, учесть выданные купюры в банкомате и вернуть их в возвращаемом vector-е
    // - если целиком запрошенную сумму выдать невозможно, не выдавать ничего и вернуть пустой vector
    std::vector<unsigned int> withdraw_large(unsigned int amount, unsigned short int currency);

    // Снять сумму amount в валюте currency, выдав её максимально мелкими купюрами
    // - если операция прошла успешно, учесть выданные купюры в банкомате и вернуть их в возвращаемом vector-е
    // - если целиком запрошенную сумму выдать невозможно, не выдавать ничего и вернуть пустой vector
    std::vector<unsigned int> withdraw_small(unsigned int amount, unsigned short int currency);

    // Вернуть максимальную сумму, доступную в валюте currency
    unsigned int check_reserve(unsigned short int currency);
};
Указание 1: банкомат поддерживает строго 3 валюты, можно закладываться, что код currency будет всегда строго из набора {0, 1, 2}, некорректные коды можно не обрабатывать.

Указание 2 (важное!): в полной постановке это достойная комбинаторная задача. Но сейчас в контрольной полное решение можно не писать. Достаточно локально жадно перебирать купюры с заданного конца, пропуская заведомо неподходящие и набирая запрошенную сумму из остальных. Например, у вас есть купюры {100, 500, 500, 1000, 2000}. Если запрошена сумма "1000 крупными", то идём от больших к меньшим, находим подходящую 1000, выдаём её - всё хорошо. Но если запрошена сумма "1000 мелкими", то такой алгоритм поведёт себя плохо - найдёт и отложит 100 (текущая сумма 100), затем найдёт и отложит 500 (текущая сумма 600), затем найдёт ещё 500 и с грустью сообщит, что выдать 1000 мелкими невозможно. В жизни так писать, конечно, не надо. Но сейчас в условиях цейтнота на контрольной такой локально жадный алгоритм будет достаточен - сложных случаев просто не будет в тестах.

Ремарка 1: в реальности для кода валюты было бы логичнее использовать enum-ы. Но в контрольной мы не стали.

Ремарка 2: в реальности из операций снятия было бы логично бросать exception-ы. Но в данной задаче мы не стали.

Для базового тестирования можете использовать следующий пример:

#include <iostream>
#include <vector>

using namespace std;

const unsigned short int RUB = 0;
const unsigned short int USD = 1;
const unsigned short int NCC = 2;

int main()
{
    vector<unsigned int> rubles = {50, 100, 100, 500, 50, 1000, 100, 100, 1000, 5000};
    vector<unsigned int> dollars = {100, 100, 100};
    vector<unsigned int> nuka_cola_caps = {1, 1, 1, 1, 1};

    ATM atm;
    atm.deposit(rubles, RUB);
    atm.deposit(dollars, USD);
    atm.deposit(nuka_cola_caps, NCC);

    cout << "Reserves: " << endl;
    for(unsigned short int code = 0; code <= 2; code++) {
        cout << "Currency " << code << ": " << atm.check_reserve(code) << endl;
    }

    vector<unsigned int> result;
    result = atm.withdraw_large(1000, RUB);
    cout << "Asked withdraw_large for 1000 RUB, got " << result.size() << " banknotes" << endl;

    result = atm.withdraw_small(1000, RUB);
    cout << "Asked withdraw_small for 1000 RUB, got " << result.size() << " banknotes" << endl;

    result = atm.withdraw_small(1000, USD);
    cout << "Asked withdraw_small for 1000 USD, got " << result.size() << " banknotes" << endl;

    result = atm.withdraw_large(3, NCC);
    cout << "Asked withdraw_large for 3 NCC, got " << result.size() << " banknotes" << endl;

    cout << "Reserves: " << endl;
    for(unsigned short int code = 0; code <= 2; code++) {
        cout << "Currency " << code << ": " << atm.check_reserve(code) << endl;
    }

    return 0;
}
Данный пример должен вывести:

Reserves: 
Currency 0: 8000
Currency 1: 300
Currency 2: 5
Asked withdraw_large for 1000 RUB, got 1 banknotes
Asked withdraw_small for 1000 RUB, got 7 banknotes
Asked withdraw_small for 1000 USD, got 0 banknotes
Asked withdraw_large for 3 NCC, got 3 banknotes
Reserves: 
Currency 0: 6000
Currency 1: 300
Currency 2: 2
Внимание:

Отправлять в контест нужно только класс ATM c реализацией его методов. Также нужно отправить необходимые include-ы и using-и к нему.
Отправлять функцию main не нужно.
Язык:	g++-vg - GNU C++ (valgrind) 4.8.3


Сдать решение задачи asteroids
Полный балл:	30
Штраф за посылку:	1
Ограничение времени:	2 с
Ограничение реального времени:	2 с
Ограничение памяти:	64M
Паранойя
Секретная космическая станция отслеживает все объекты, которые приближаются к ней на достаточно близкое пороговое расстояние. Это очень старая станция, и радар на ней сломан. Он уже не позволяет оценить скорость пролетающих объектов, только фиксировать отдельные кадры. Станция имеет весьма обрывочные сведения о том, что происходит вокруг.

Поток информации о замеченных астероидах идет в формате (uuid, ts, x, y, z), где uuid - уникальный идентификатор астероида; ts - момент времени, в который этот астероид был замечен; x, y, z - его координаты в этот момент времени. Обратите внимание, что в системе могут быть сбои - записи о разных моментах времени могут перемешаться и идти в неправильном порядке. Ориентируйтесь на значение ts.

Старый радар позволяет в каждый момент времени засечь не более одного объекта, поэтому все ts в потоке данных строго уникальны.

Вам нужно определить, какие из замеченных астероидов хотя бы один раз за всё время наблюдения оказались слишком близко к станции, и вывести их идентификаторы в порядке первого появления.

Указание: числа с плавающей точкой сравнивать с точностью до 1e-6 везде, где это потребуется.

Входные данные
x0, y0, z0, R (четыре числа с плавающей точкой) - координаты станции и пороговое расстояние;

N (одно целое число) - количество записей;

N записей, каждая состоит из набора uuid, ts, x, y, z (два больших целых числа и три числа с плавающей точкой), где uuid - уникальный идентификатор астероида; ts - момент времени, в который этот астероид был замечен; x, y, z - его координаты в этот момент времени.

Выходные данные
Набор идентификаторов астероидов (uuid), оказавшихся хотя бы один раз за всё время наблюдения на расстоянии меньше R от станции (x0, y0, z0), без повторов, отсортированный в порядке первого появления данного астероида на радаре (по возрастанию ts).

Примеры
Вход

Выход

0 0 0 1
6
123456 100 1 1 1
258736 201 5 5 5
545587 300 0 0.5 0.5
254587 200 0.5 0.5 0
368636 500 0 0 0
854568 900 0 0 13
254587
545587
368636
10 10 10 1
4
5876869 123456 10 10 9.5
1357458 158766 10 10 10.5
8768736 23686 100 100 10
5876869 687686 10 10 10.5
5876869
1357458
Язык:	g++-vg - GNU C++ (valgrind) 4.8.3
